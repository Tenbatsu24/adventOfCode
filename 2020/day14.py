import copy

from day_base import Day


def get_possible_addresses(address, bitmask):
    """
    Get all the possible addresses with the given bitmask
    :param address: The 'base' address that will be used
    :param bitmask: The bitmask to apply
    :return: A list of all the possible memory addresses that are generated by the floating bitmask
    """
    # Set the required bits to 1
    bitmask = [(-1 if bit == "X" else int(bit)) for bit in bitmask]
    for i in range(36):
        if bitmask[i] == 1 and (2 ** (35 - i)) & address == 0:
            address += 2 ** (35 - i)

    # Generate all possible options
    addresses = [address]
    for i in range(36):
        if bitmask[i] == -1:
            check_val = (2 ** (35 - i))
            for address in copy.deepcopy(addresses):
                if address & check_val == 0:
                    # The address is zero at this bit so add the one version
                    addresses.append(address + check_val)
                else:
                    # The address has already the one bit, but not the zero bit
                    addresses.append(address - check_val)
    return addresses


class Day14(Day):

    def __init__(self):
        super().__init__(2020, 14, 'Docking Data', expected_a=None, expected_b=208, debug=False)

    def part_a(self) -> int:
        mask = [-1 for _ in range(36)]
        memory = {}
        for line in self.input:
            left, right = line.split(" = ")
            if left == "mask":
                mask = [(-1 if x == "X" else int(x)) for x in right]
            else:
                mem_addr = int(left.replace("mem", "")[1:-1])
                value = int(right)

                # Apply the bit mask bit by bit
                for i in range(36):
                    mask_bit = mask[35 - i]
                    if mask_bit == 0:
                        # If the bit is not already zero, subtract 2**i effectively setting only that bit to zero
                        if value & 2**i != 0:
                            value -= 2**i
                    if mask_bit == 1:
                        # If the bit is not already set, add 2**i effectively setting only that bit to one
                        if value & 2**i == 0:
                            value += 2**i
                memory[mem_addr] = value
        return sum(memory.values())

    def part_b(self) -> int:
        mask = None
        memory = {}
        for line in self.input:
            left, right = line.split(" = ")
            if left == "mask":
                mask = right
            else:
                mem_addr = int(left.replace("mem", "")[1:-1])
                mem_addresses = get_possible_addresses(mem_addr, mask)
                value = int(right)
                for addr in mem_addresses:
                    memory[addr] = value
        return sum(memory.values())

if __name__ == '__main__':
    (Day14()).run()
